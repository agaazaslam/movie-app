// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}
// The additional parameters you want to pass to the `fetch` instance.
let defaultFetchParams = {}
const defaultJsonType = { 'Content-type': 'application/json; charset=utf-8' }

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./client-types.d.ts').Client['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./client-types.d.ts').Client['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

/**  @type {import('./client-types.d.ts').Client['setDefaultFetchParams']} */
export const setDefaultFetchParams = (fetchParams) => { defaultFetchParams = fetchParams }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _movieDbGetMovies (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'cursor', 'startAfter', 'endBefore', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.ilike', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.popularity.eq', 'where.popularity.neq', 'where.popularity.gt', 'where.popularity.gte', 'where.popularity.lt', 'where.popularity.lte', 'where.popularity.like', 'where.popularity.ilike', 'where.popularity.in', 'where.popularity.nin', 'where.popularity.contains', 'where.popularity.contained', 'where.popularity.overlaps', 'where.posterUrl.eq', 'where.posterUrl.neq', 'where.posterUrl.gt', 'where.posterUrl.gte', 'where.posterUrl.lt', 'where.posterUrl.lte', 'where.posterUrl.like', 'where.posterUrl.ilike', 'where.posterUrl.in', 'where.posterUrl.nin', 'where.posterUrl.contains', 'where.posterUrl.contained', 'where.posterUrl.overlaps', 'where.rating.eq', 'where.rating.neq', 'where.rating.gt', 'where.rating.gte', 'where.rating.lt', 'where.rating.lte', 'where.rating.like', 'where.rating.ilike', 'where.rating.in', 'where.rating.nin', 'where.rating.contains', 'where.rating.contained', 'where.rating.overlaps', 'where.releasedYear.eq', 'where.releasedYear.neq', 'where.releasedYear.gt', 'where.releasedYear.gte', 'where.releasedYear.lt', 'where.releasedYear.lte', 'where.releasedYear.like', 'where.releasedYear.ilike', 'where.releasedYear.in', 'where.releasedYear.nin', 'where.releasedYear.contains', 'where.releasedYear.contained', 'where.releasedYear.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.ilike', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.voteAverage.eq', 'where.voteAverage.neq', 'where.voteAverage.gt', 'where.voteAverage.gte', 'where.voteAverage.lt', 'where.voteAverage.lte', 'where.voteAverage.like', 'where.voteAverage.ilike', 'where.voteAverage.in', 'where.voteAverage.nin', 'where.voteAverage.contains', 'where.voteAverage.contained', 'where.voteAverage.overlaps', 'where.votesCount.eq', 'where.votesCount.neq', 'where.votesCount.gt', 'where.votesCount.gte', 'where.votesCount.lt', 'where.votesCount.lte', 'where.votesCount.like', 'where.votesCount.ilike', 'where.votesCount.in', 'where.votesCount.nin', 'where.votesCount.contains', 'where.votesCount.contained', 'where.votesCount.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.id', 'orderby.popularity', 'orderby.posterUrl', 'orderby.rating', 'orderby.releasedYear', 'orderby.title', 'orderby.updatedAt', 'orderby.voteAverage', 'orderby.votesCount']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/movies/?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbGetMovies']} */
export const movieDbGetMovies = async (request) => {
  return await _movieDbGetMovies(baseUrl, request)
}
async function _movieDbCreateMovie (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/db/movies/?${searchParams.toString()}`, {
    method: 'POST',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbCreateMovie']} */
export const movieDbCreateMovie = async (request) => {
  return await _movieDbCreateMovie(baseUrl, request)
}
async function _movieDbUpdateMovies (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.ilike', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.popularity.eq', 'where.popularity.neq', 'where.popularity.gt', 'where.popularity.gte', 'where.popularity.lt', 'where.popularity.lte', 'where.popularity.like', 'where.popularity.ilike', 'where.popularity.in', 'where.popularity.nin', 'where.popularity.contains', 'where.popularity.contained', 'where.popularity.overlaps', 'where.posterUrl.eq', 'where.posterUrl.neq', 'where.posterUrl.gt', 'where.posterUrl.gte', 'where.posterUrl.lt', 'where.posterUrl.lte', 'where.posterUrl.like', 'where.posterUrl.ilike', 'where.posterUrl.in', 'where.posterUrl.nin', 'where.posterUrl.contains', 'where.posterUrl.contained', 'where.posterUrl.overlaps', 'where.rating.eq', 'where.rating.neq', 'where.rating.gt', 'where.rating.gte', 'where.rating.lt', 'where.rating.lte', 'where.rating.like', 'where.rating.ilike', 'where.rating.in', 'where.rating.nin', 'where.rating.contains', 'where.rating.contained', 'where.rating.overlaps', 'where.releasedYear.eq', 'where.releasedYear.neq', 'where.releasedYear.gt', 'where.releasedYear.gte', 'where.releasedYear.lt', 'where.releasedYear.lte', 'where.releasedYear.like', 'where.releasedYear.ilike', 'where.releasedYear.in', 'where.releasedYear.nin', 'where.releasedYear.contains', 'where.releasedYear.contained', 'where.releasedYear.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.ilike', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.voteAverage.eq', 'where.voteAverage.neq', 'where.voteAverage.gt', 'where.voteAverage.gte', 'where.voteAverage.lt', 'where.voteAverage.lte', 'where.voteAverage.like', 'where.voteAverage.ilike', 'where.voteAverage.in', 'where.voteAverage.nin', 'where.voteAverage.contains', 'where.voteAverage.contained', 'where.voteAverage.overlaps', 'where.votesCount.eq', 'where.votesCount.neq', 'where.votesCount.gt', 'where.votesCount.gte', 'where.votesCount.lt', 'where.votesCount.lte', 'where.votesCount.like', 'where.votesCount.ilike', 'where.votesCount.in', 'where.votesCount.nin', 'where.votesCount.contains', 'where.votesCount.contained', 'where.votesCount.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/db/movies/?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbUpdateMovies']} */
export const movieDbUpdateMovies = async (request) => {
  return await _movieDbUpdateMovies(baseUrl, request)
}
async function _movieDbGetMovieById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/movies/${request['id']}?${searchParams.toString()}`, {
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbGetMovieById']} */
export const movieDbGetMovieById = async (request) => {
  return await _movieDbGetMovieById(baseUrl, request)
}
async function _movieDbUpdateMovie (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/db/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbUpdateMovie']} */
export const movieDbUpdateMovie = async (request) => {
  return await _movieDbUpdateMovie(baseUrl, request)
}
async function _movieDbDeleteMovies (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  if (request) {
    queryParameters.forEach((qp) => {
      const queryValue = request?.[qp]
      if (queryValue) {
        if (Array.isArray(queryValue)) {
          queryValue.forEach((p) => searchParams.append(qp, p))
        } else {
          searchParams.append(qp, queryValue.toString())
        }
      }
      delete request?.[qp]
    })
  }

  const body = request
  const isFormData = body instanceof FormData
  const headers = {
    ...defaultHeaders,
    ...(isFormData || body === undefined) ? {} : defaultJsonType
  }

  const response = await fetch(`${url}/db/movies/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: isFormData ? body : JSON.stringify(body),
    headers,
    ...defaultFetchParams
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./client-types.d.ts').Client['movieDbDeleteMovies']} */
export const movieDbDeleteMovies = async (request) => {
  return await _movieDbDeleteMovies(baseUrl, request)
}
async function _getDbTest (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/test`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./client-types.d.ts').Client['getDbTest']} */
export const getDbTest = async (request) => {
  return await _getDbTest(baseUrl, request)
}
async function _getDbPopular (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/popular`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./client-types.d.ts').Client['getDbPopular']} */
export const getDbPopular = async (request) => {
  return await _getDbPopular(baseUrl, request)
}
async function _getDbTrending (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/trending`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./client-types.d.ts').Client['getDbTrending']} */
export const getDbTrending = async (request) => {
  return await _getDbTrending(baseUrl, request)
}
async function _getDbSearch (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/db/search`, {
    headers,
    ...defaultFetchParams
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  const responseType = response.headers.get('content-type')?.startsWith('application/json') ? 'json' : 'text'
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response[responseType]()
  }
}

/**  @type {import('./client-types.d.ts').Client['getDbSearch']} */
export const getDbSearch = async (request) => {
  return await _getDbSearch(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    movieDbGetMovies: _movieDbGetMovies.bind(url, ...arguments),
    movieDbCreateMovie: _movieDbCreateMovie.bind(url, ...arguments),
    movieDbUpdateMovies: _movieDbUpdateMovies.bind(url, ...arguments),
    movieDbGetMovieById: _movieDbGetMovieById.bind(url, ...arguments),
    movieDbUpdateMovie: _movieDbUpdateMovie.bind(url, ...arguments),
    movieDbDeleteMovies: _movieDbDeleteMovies.bind(url, ...arguments),
    getDbTest: _getDbTest.bind(url, ...arguments),
    getDbPopular: _getDbPopular.bind(url, ...arguments),
    getDbTrending: _getDbTrending.bind(url, ...arguments),
    getDbSearch: _getDbSearch.bind(url, ...arguments)
  }
}